# build-your-own -x

新手（编程不到1年）： 先做命令行工具，熟悉语言特性；再试试HTTP服务器，理解网络基础

有点经验（1-3年）： 可以挑战Git核心功能、Shell解释器、简易数据库这类项目

老手（3年以上）： 直接上Docker容器、编程语言编译器、操作系统内核

## C++ : Build your own Redis from Scratch

### 教程

https://build-your-own.org/redis/

### 1.0 引言

- 学习搭建Redis服务器，将面临**网络编程**和**数据结构**的学习，这将让你能够开发任何软件。
- Redis 是一个内存键值存储，主要用于缓存，因为没有比内存更快的存储。
- 语言上我们使用C/C++，因为你将被迫面临自己搭建网络，自己学习数据结构的压力。强制你去学习网络和数据结构。
- 每个章节都是渐进式的。在章节的引导下，最终的代码仅有1200行。整个项目将足够精简，只在意一些原则上的问题。

### 2.1 套接字编程

### 核心概念：从黑盒到代码

网络编程不仅仅是调用“发送”和“接收”数据的API，其背后隐藏着许多关键概念，理解它们是编写网络应用的基础。

- **TCP字节流与协议**：TCP协议并不直接传输“消息”，而是提供一个**连续的、无边界的字节流**。应用程序需要自己定义一种**应用层协议**，来解释这个字节流并正确地将其切分成一个个独立的消息。
- **数据序列化**：网络只传输0和1。为了发送字符串、结构体等高级对象，需要将其转换为字节序列（**序列化**），并在接收端还原（**反序列化**）。手动处理比特和字节是理解底层编程的好方法。
- **并发编程**：服务端需要同时处理大量连接。为了高效利用硬件资源，现代软件通常采用**基于事件循环的事件驱动并发模型**（如Nginx、Redis使用的方式），这是需要重点掌握的编程范式。

### 网络层次：程序员的视角

从程序员的角度看，网络协议栈主要关注IP及其之上的层次，它们解决了不同的问题。

| 功能层 | 核心协议/概念 | 主要作用 |
| :--- | :--- | :--- |
| **可靠、有序的字节流** | **TCP** | 在不可靠的IP层之上，提供可靠、有序的字节流传输，自动处理丢包和乱序。 |
| **多路复用** | **UDP/TCP中的端口号** | 通过16位的端口号，将网络数据分发到同一台机器上的不同应用程序。 |
| **小、离散的消息** | **IP** | 处理基础的、基于数据包（Packet）的网络传输。 |

- **核心关注点**：对于应用开发，我们主要关心**IP地址、端口号、以及TCP或UDP协议**的选择。这是设计所有网络应用的起点。
- **TCP vs. UDP**：它们语义不兼容。TCP提供可靠的字节流，适合需要按顺序、无差错传输的场景（如HTTP、Redis）；UDP则更简单，只提供“IP+端口”的封装。大多数请求-响应协议都基于TCP。

### **Socket 编程原语**

Socket（套接字）是操作系统提供的网络编程API句柄（在Linux上称为文件描述符fd），用于管理网络连接。

#### **服务端：监听与连接**
1.  **创建监听Socket**：
    *   `socket()`: 创建一个无类型的socket句柄。
    *   `bind()`: 将该句柄与特定的IP地址和端口绑定。
    *   `listen()`: 将该句柄转换为监听socket，开始监听客户端的连接请求。
2.  **接受连接**：
    *   `accept()`: 从监听socket中接受一个传入的TCP连接。这是一个阻塞调用，直到有客户端连接。它会返回一个新的、代表此连接的socket句柄（`conn_fd`）。
    *   **处理与关闭**：使用`conn_fd`与客户端通信，完成后调用`close(conn_fd)`关闭连接。

#### **客户端：发起连接**
1.  **创建Socket**：`socket()`创建一个socket句柄。
2.  **发起连接**：`connect()`使用该句柄向服务器的地址和端口发起连接。
3.  **通信与关闭**：连接成功后，使用该句柄进行读写，最后调用`close()`关闭。

#### **通用读写操作**
*   **`read()` / `write()`**：对于TCP socket，这些操作用于从字节流中读取或写入数据。每次调用可能只处理部分数据。
*   **`send()` / `recv()`**：`read/write`的变体，提供更细粒度的控制。
*   **重要提示**：虽然文件、管道等也使用`read/write`，但由于TCP和UDP的语义不同，不能编写一套代码同时适用于两者。

## C++ : Write your own Operating System

### 教程

两个学习如何构建自己的操作系统的网址：
http://www.lowlevel.eu/wiki/Hauptseite 
https://wiki.osdev.org/Expanded_Main_Page

注意，通过上面两个网址，我们可以了解到，对于初学者，直接上手系统开发并不是很明智的选择。

在开始之前，先衡量一下自己是否有如下条件：
- 有多个项目的成功经验，是一名有经验的用户级应用开发者。通过构建操作系统的项目来丰富编程经验不是一个很好的选择。
- 有多年（若仅仅是学习，3~5年的编程经验即可）的多语言和多环境开发经验（如果是独立开发，要求会比较高，需要10年编程经验，其中包括几年的汇编或者C语言，并且将其用于系统编程的经验）。其中，关于UNIX的深度使用，是一个很好的系统设计开发参考经验。
- 有一定的项目管理能力，具有良好的设计能力。这是一个大项目，我们需要对你自己所进行的事有完整的目标估算和阶段性的检验复盘，良好的设计会让你的项目变得井井有条，并有效降低项目的代码复杂度。
- 有充足的时间和耐心（Linus在做自己的操作系统时，也花费了将近1年时间）。
- 有一定的英文阅读能力（基本上所有的参考资料，基础的如本教程中的wiki和视频，较难的如官方文档等，均为英文）。
- 不要抱有过高的预期。

视频教程：
https://www.youtube.com/playlist?list=PLHh55M_Kq4OApWScZyPl5HhgsTJS9MZ6M

### 环境

```
Intel Pentium Dual Core T4400
Linux Mint 17.1 (Rebecca)
Kernel 3.13.0-37-generic
KDE 4.14.2

sudo apt-get install
    g++
    binutils
    libc6-dev-i386
```